import { log } from "./util/log.js";

// Used to verify if a G-Code file was sliced with a particular slicer
const generatedByPrusaRegex = /; generated by PrusaSlicer/;

// Extracts metadata from G-Code files produced from PrusaSlicer (https://github.com/prusa3d/PrusaSlicer)
const getPrinterModelRegexPrusa = /; printer_model = (.+)/;

/** Supports reading metadata in G-Code scripts and removes comments and empty lines in them */
export class GCodeScript {
    #supportedHardware = [];
    #gcodeScriptIndex;
    #gcodeScriptArr;
    #id;

    constructor(gcodeScript, id = 'unassigned') {
        if (typeof gcodeScript !== 'string')
            throw new TypeError('The G-Code script constructor expects a string as a G-Code script');

        if (typeof id !== 'string')
            throw new TypeError(`id's are meant to be unique strings that distinguish this G-Code script from others. Not ${typeof id}`);

        // Get metadata from the G-Code script if we can
        if (generatedByPrusaRegex.test(gcodeScript)) {
            const modelName = getPrinterModelRegexPrusa.exec(gcodeScript)?.[1];
            
            if (typeof modelName === 'string') {
                this.#supportedHardware.push(modelName);
            } else {
                log(
                    `WARNING: PrusaSlicer has updated how they store the metadata in their auto-generated G-Code files. ${getPrinterModelRegexPrusa} no longer works`,
                    'gcode_script.js'
                );
            }
        }

        // Remove empty lines and comments in the G-Code script
        this.#gcodeScriptArr = gcodeScript
            .replaceAll(/;.*/g, '')
            .split('\n')
            .filter(str => str !== '');
        
        this.#id = id;
    }

    /** Returns whether the current printer model is supported by this G-Code script */
    supportsPrinter(printerModel) {
        if (this.#supportedHardware.includes(printerModel))
            return true;
        else
            return false;
    }

    /**
     * Returns the next G-code command as a string encoded using stringEncoding
     * Defaults to 'utf-8'
     * If the end of G-Code script has been reached, then an error will be thrown
     */
    nextGcodeCommand(stringEncoding = 'utf-8') {
        const nextCommand = this.#gcodeScriptArr[this.#gcodeScriptIndex];

        if (nextCommand === undefined)
            throw new Error(`The job "${this.name}" has no more G-code commands to send`);

        this.#gcodeScriptIndex++;

        return nextCommand.toString(stringEncoding);
    }

    reachedEndOfScript() {
        return this.#gcodeScriptArr[this.#gcodeScriptIndex] === undefined;
    }
}
